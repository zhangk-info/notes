## redis相关知识
    远程内存非关系型数据库

纯内存操作
单线程操作，避免了频繁的上下文切换
采用了非阻塞I/O多路复用机制
    
### redis数据类型：多样的数据结构
    https://redis.io/topics/data-types-intro
* String 二进制安全字符串。
* Lists 列表：根据插入顺序排序的字符串元素的集合。它们基本上是链表。
* Sets 集：唯一，未排序的字符串元素的集合。
* ZSets 与Sets相似的有序sets，但每个字符串元素都与一个称为score的浮点值相关联。元素总是按它们的分数排序，因此与Sets不同，可以检索一系列元素（例如，您可能会问：给我前10名或后10名）。
* Hashes 哈希，是由与值关联的字段组成的映射。字段和值都是字符串。这与Ruby或Python哈希非常相似。
* Bit arrays(or simply bitmaps) 位数组（或简称为位图）：可以使用特殊命令像位数组一样处理字符串值：您可以设置和清除单个位，计数所有设置为1的位，找到第一个设置或未设置的位，等等。
* HyperLogLogs：这是一个概率数据结构，用于估计集合的基数。别害怕，它比看起来更简单...请参阅本教程的HyperLogLog部分。
* Streams 流：提供抽象日志数据类型的类地图项的仅追加集合。在“ Redis流简介”中对它们进行了深入 介绍。

### redis持久化：RDB和AOF持久化数据
* RDB 镜像文件
* AOF 日志形式 包含命令

### 高可用/分布式：哨兵模式（Sentinel） & 集群模式(Cluster)
* 哨兵模式（主master从slave模式）： 所有节点的记录都是一样的，当主节点挂了的时候哨兵选举一个从节点作为主。
* 集群模式（分布式）：将数据分散到不同节点，通过缓存key通过hash将数据路由到不同的节点

### 事务： 不支持回滚，但可用于命令一次传输，整体执行
### 流水
### 发布/订阅 = 消息队列
### lua脚本


### redis不是强一致性的数据库 异步复制
    主节点挂了的时候，如果数据没有同步到备节点，是会出现数据丢失的情况
* 脑裂
* 分区

### redis与数据库的双写一致性问题
    redis只能保证最终一致性，如果对数据有强一致性要求，不能放缓存。或者加分布式锁处理。


### redis三种集群模式
https://www.cnblogs.com/wanghaokun/p/10366689.html
#### redis 分片集群
    工作原理如下

    客户端与Redis节点直连,不需要中间Proxy层，直接连接任意一个Master节点
    根据公式HASH_SLOT=CRC16(key) mod 16384，计算出映射到哪个分片上，然后Redis会去相应的节点进行操作
    具有如下优点:
    (1)无需Sentinel哨兵监控，如果Master挂了，Redis Cluster内部自动将Slave切换Master
    (2)可以进行水平扩容
    (3)支持自动化迁移，当出现某个Slave宕机了，那么就只有Master了，这时候的高可用性就无法很好的保证了，万一master也宕机了，咋办呢？ 针对这种情况，如果说其他Master有多余的Slave ，集群自动把多余的Slave迁移到没有Slave的Master 中。

    缺点:
    (1)批量操作是个坑
    (2)资源隔离性较差，容易出现相互影响的情况。


##### 用Bitmaps做日活统计
```
/**
* 更新并获取累计用户数
*/

```


##### 用Sets做性能监控
