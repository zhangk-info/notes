# 锁
```
* 轻量级锁/自旋锁 ：忙等待/自旋等待
* 重量级锁 ： 队列等待，操作系统调度
    引申问题：轻量级锁一定比重量级锁轻吗？（轻量级锁一定比重量级锁执行效率高吗？）
    答：不一定！当锁竞争比较激烈或者锁定时间较长的时候，多个线程会一直在cpu中自旋等待大量消耗cpu资源。
```

## 自旋锁
```
AtomicInteger m = new AtomicInteger();
m.incrementAndGet();
->
compareAndSwapInt : CAS 比较并交换 底层是native c++的实现
    我拿过来0修改成1，写回去之前比较你的值是不是依然是我拿过来的0，如果是交换，如果不是继续循环直到是我拿到的0 

引申问题：
ABA问题 - 版本号：
0 - x - 0 虽然你比较的结果也是0，但是此0非彼0，此0已经是经过其他线程改变又改回来的值。
CAS的原子性问题：
比较完成之后改之前其他线程将值改变了？ 

```

## 偏向锁 自旋锁/轻量级锁
一个线程叫偏向锁 2个线程叫自旋锁 

## 锁的4中状态 = synchronized的实现原理
new  偏向锁状态 轻量级锁状态 重量级锁状态

## 可重入锁
## 类锁 对象锁

## 公平锁和非公平锁
```
公平锁可通过new ReentrantLock(true)实现
```

## 悲观锁和乐观锁 
```
悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。
乐观锁：假定不会发生并发冲突，只在提交操作时检测是否违反数据完整性。（使用版本号或者时间戳来配合实现）
```

## 共享锁和排它锁
```
共享锁：如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排它锁。获准共享锁的事务只能读数据，不能修改数据。
共享锁又称为读锁，一个线程给数据加上共享锁后，其他线程只能读数据，不能修改
排它锁：如果事务T对数据A加上排它锁后，则其他事务不能再对A加任何类型的锁。获得排它锁的事务即能读数据又能修改数据。
排他锁又称为写锁，和共享锁的区别在于，其他线程既不能读也不能修改。
```

## 读写锁 
* ReentrantReadWriteLock
## 互斥锁
所谓互斥锁就是指一次最多只能有一个线程持有的锁。在JDK中synchronized和JUC的Lock就是互斥锁。

## 无锁 
```
1. double check + volatile 例子：spring单例模式bean的生成
2. 线程本地存储： ThreadLocal
3. CAS实现自旋锁 例子：automic
4. 协程：在单线程里面实现 
```

## volatile
```
volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； 
synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
volatile仅能使用在变量级别；
synchronized则可以使用在变量、方法、和类级别的
volatile仅能实现变量的修改可见性，不能保证原子性；
而synchronized则可以保证变量的修改可见性和原子性
volatile不会造成线程的阻塞；
synchronized可能会造成线程的阻塞。
volatile标记的变量不会被编译器优化；
synchronized标记的变量可以被编译器优化
```

## 编译器优化 synchronized标记的变量可以被编译器优化
### 锁消除
```
    public synchronized StringBuffer append(StringBuffer sb) {
        super.append(sb);
        return this;
    }
有的代码虽然加了锁，但是这个锁锁住的对象是当前线程私有的变量，是可以被安全的消除。
在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了
```
    
### 锁粗化
```
原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制的尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。
但是，如果一些列的联系操作都是同一个对象反复加上和解锁，甚至加锁操作是出现在循环体中的，那么即使没有线程竞争，频繁地进行互斥同步操作也导致不必要的性能损耗。
如果StringBuffer sb = new StringBuffer();
定义在方法体之外，那么就会有线程竞争，但是每个append()操作都对同一个对象反复加锁解锁，
那么虚拟机探测到有这样的情况的话，会把加锁同步的范围扩展到整个操作序列的外部，
即扩展到第一个append()操作之前和最后一个append()操作之后，
这样的一个锁范围扩展的操作就称之为锁粗化。
```
