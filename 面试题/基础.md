# ==和equals区别
* ==对比的是栈中的值，基本数据类型是变量值，引用类型是堆中内存对象的地址
* equals: object中默认也是采用==比较，通常会重写equals
```
String str1 = "hello";
String str2 = new String("hello");
String str3 = str2;

str1 == str2 // false str1的引用地址指向方法区常量池,str2的引用地址指向堆
str2 == str3 // true  2和3是同一个引用
str1 == str3 // false str1的引用地址指向方法区常量池,str3的引用地址和str2是同一个指向堆

str1.equals(str2).equals(str3) // true String类重写了equals，判断引用地址再判断值（字符编码要相同），任何满足都相等
```

# final
* final的作用
  * 修饰类： 类不可继承
  * 修饰方法： 方法不可被子类覆盖，但可以重载
  * 修饰变量： 表示变量一旦被赋值就不可以更改它的值
* 匿名内部类和局部内部类为什么只能访问局部final变量？否则编译报错
```java
public class Test {
    public void test(final int b) {
        final int a = 10;
        // 匿名内部类
        new Thread() {
            public void run() {
                System.out.println(a);
                System.out.println(b);
            }
        }.start();
    }
}
```

1. 编译之后会产生两个class文件: Test.class Test1.class。 
2. 内部类和外部类是同一级别的。内部类不会因为定义在方法中就会随着方法的执行完毕而被销毁。
3. 但是当外部类方法执行完毕后，外部类的局部变量会被销毁。
4. 为了解决这个问题：就将外部类的局部变量final定义，复制了一份作为内部类的成员变量。
5. 另外：将外部类的局部变量复制为内部类的成员变量时，必须保证两个变量一样。即，内部类不可修改该成员变量。

# String|StringBuffer|StringBuilder的区别及使用场景
* String类是final修饰的类，不可变，每次操作都会产生新的String对象。操作会导致内存浪费。
* StringBuffer&StringBuilder都是在原对象上进行操作。操作不会造成内存浪费
  * StringBuffer是线程安全的，StringBuilder是线程不安全的。 StringBuffer的方法都是synchronized修饰的。

# 重载和重写的区别
* 重写：子类重写父类方法。方法名和参数列表都相同。返回值范围小于等于父类；抛出异常范围小于等于父类；访问修饰符范围大于等于父类；父类private方法不可重写；
* 重载：方法名相同，其他可以不同。不能有两个其他相同但返回值不同的方法（编译报错）；

# 接口和抽象类的区别
* 抽象类可以存在普通成员方法；接口只能存在方法定义(public abstract)和有且只有一个default方法;
* 抽象类的成员变量可以是各种类型的；接口的成员变量只能是静态常量(public static final);
* 抽象类只能有一个继承；接口可以有多个实现；（一个类只能继承一个类，但是可以实现多个接口）

# List和Set的区别
* List有序可重复；
* Set无序不可重复；允许一个NULL,不可重复

# hashCode与equals
* equals不重写默认使用Objects的equals,默认使用的是==
* hashCode : public native int hashCode(); 哈希码，散列码，int类型；
* 哈希表： jvm存放了一张表（key-value）用于快速确定对象在堆中的位置。对象的hashCode就是哈希表的索引key
* hashCode在重复检查中的作用：hashMap&hashSet;先检查hashCode,再检查equals()方法
```
p.hash == hash && ((p.key == key || (key != null && key.equals(k)))
```
* hash冲突： 两个对象的hash值一样，但是他们不一定是同一个对象。

# ArrayList和LinkedList的区别
* ArrayList动态数组，连续内存存储。扩容机制：复制；查询快操作慢。
* LinkedList链表，分散内存存储。查询慢操作快。只能迭代遍历。

# java 是按值传递还是按引用传递
  https://blog.csdn.net/u013309870/article/details/75499175
  The Java Spec says that everything in Java is pass-by-value. There is no such thing as “pass-by-reference” in Java.
  ```
  java数据类型可以分为两大类：基本类型（primitive types）和引用类型（reference types）。
  primitive types 包括boolean类型以及数值类型（numeric types）。numeric types又分为整型（integer types）和浮点型（floating-point type）。整型有5种：byte short int long char(char本质上是一种特殊的int)。浮点类型有float和double。
  public class Swap {
  
      public static void main(String[] args) {
          int x = 10;
          int y = 20;
          swap(x, y);
          System.out.println("x(2) = " + x); // 10
          System.out.println("y(2) = " + y); // 20
      }
       public static void swap(int x, int y) {
          int temp = x;
          x = y;
          y = temp;
          System.out.println("x(1) = " + x); // 20
          System.out.println("y(1) = " + y); // 10
      }
  }
  两个栈帧都有x,y的内存存储
  引用数据数据类型分为三种：①接口 ②类 ③数组。引用类型的按值传递，传递的是对象的地址
  public class Main{
     public static void main(String[] args){
          Foo f = new Foo("f");
          changeReference(f); // It won't change the reference!
          modifyReference(f); // It will modify the object that the reference variable "f" refers to!
     }
     public static void changeReference(Foo a){
          Foo b = new Foo("b");
          a = b;
     }
     public static void modifyReference(Foo c){
          c.setAttribute("c");
     }
  }
  ```